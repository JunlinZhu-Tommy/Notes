## TCP 重传

为了保证传输的正确性，TCP 会重传认为已经丢失的数据包。他会根据接收端发送的一系列消息判断是否出现丢包现象。当缺失数据包丢失后，TCP 启动重传操作。有两套机制：一是基于时间策略，二是基于确认信息机制。通常第二种比第一种更高效。

### 例

假设我们现在要发送 5000 个字节的数据包，因为 MSS 的限制每次传输 1000 个字节，分 5 段传输，如下图：

XXX: 图

数据包 1 发送的数据正常到达接收端，接收端回复 ACK 1001，表示 seq 为 1001 之前的数据包都已经收到，下次从 1001 开始发。 数据包 2（1001：2001）因为某些原因未能到达服务端，其他包正常到达，这时接收端也不能 ack 3 4 5 数据包，因为数据包 2 还没收到，接收端**每次只能回复 ack 1001。**

这时候发送端发现了有超过了三个相同的 ACK，就意识出现丢包行为，此时会对数据包 2 进行重传。

XXX: 图

第 2 个数据包重传成功以后服务器会回复 5001，表示 seq 为 5001 之前的数据包都已经收到了。

**永远记住 ACK 是表示这之前的包都已经全部收到**

### 快速重传

「快速重传」 快速重传的含义是：当发送端收到 3 个或以上重复 ACK，就意识到之前发的包可能丢了，于是马上进行重传，不用傻傻的等到超时再重传。

#### SACK 标识

发送 3、4、5 包收到的全部是 ACK=1001，快速重传解决了一个问题: 需要重传。但并没有说哪个包丢了，因此需要通过 SACK 标识具体到哪个**数据区间**的包丢失。

- 收到 3 号包的时候在 ACK 包中告诉发送端：喂，小老弟，我目前收到的最大连续的包序号是 1000（ACK=1001），[1:1001]、[2001:3001] 区间的包我也收到了
- 收到 4 号包的时候在 ACK 包中告诉发送端：喂，小老弟，我目前收到的最大连续的包序号是 1000（ACK=1001），[1:1001]、[2001:4001] 区间的包我也收到了
- 收到 5 号包的时候在 ACK 包中告诉发送端：喂，小老弟，我目前收到的最大连续的包序号是 1000（ACK=1001），[1:1001]、[2001:5001] 区间的包我也收到了

XXX: 图

这样发送端就清楚知道只用重传 2 号数据包就可以了，数据包 3、4、5 已经确认无误被对端收到。这种方式被称为 SACK（Selective Acknowledgment）。

TODO: MSS 是什么？
TODO: ACK 为什么占用一个字节？
TODO: seq？
